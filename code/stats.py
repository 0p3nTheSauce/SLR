"""
Provide functions to accumulate and summarise statistics for the WLASL dataset, including:
- Class-level statistics (instances, signers, variations)
- Set-level statistics (train/val/test)
- LaTeX table generation for reporting
- Visualisation utilities for exploring the distribution of instances and signers per class.

The structure of the input is directly influenced by the original WLASL JSON format:
- NOTE: For consistency, these methods should be altered to use the format available in preprocessed folder (generated by preprocess.py). This should be simple given they are very similar
- Before this, preprocess.py needs to be updated to include more meta-info when preprocessing
- It would be faster for preprocess to include a method which updates preprocessed file (to avoid rerunning the bounding box step specifically)

Naming convention:
- set: one of train, test and val
- split one of asl100, asl300, asl1000, asl2000

"""

import json
from configs import WLASL_ROOT, SPLIT_DIR, CLASSES_PATH
from pathlib import Path
from typing import List, Dict, TypedDict, TypeAlias, Literal, Optional
import matplotlib.pyplot as plt


# =============================================================================
#                       TYPE DEFINITIONS
# =============================================================================

AVAIL_SETS: TypeAlias = Literal["train", "val", "test"]
AVAIL_SPLITS: TypeAlias = Literal["asl100", "asl300", "asl1000", "asl2000"]


class instance_dict(TypedDict):
    """Represents a single instance of a gloss in the dataset."""
    bbox: List[int]
    frame_end: int
    frame_start: int
    instance_id: int
    signer_id: int
    source: str
    split: str
    url: str
    variation_id: int
    video_id: str


class gloss_dict(TypedDict):
    """Represents a single gloss and its associated instances."""
    gloss: str
    instances: List[instance_dict]


class class_stats(TypedDict):
    """Represents statistics for a single gloss class."""

    num_instances: int
    num_signers: int
    num_variations: int


class set_stats(TypedDict):
    """Represents statistics for a data subset (train/val/test)."""

    num_instances: int
    num_signers: int
    per_class_stats: Dict[str, class_stats]  # key is the class name


class split_stats(TypedDict):
    """Represents statistics for a single dataset split (asl100, asl300, asl1000, asl2000)."""

    num_classes: int
    num_instances: int
    num_signers: int
    per_set_stats: Dict[AVAIL_SETS, set_stats]


# =============================================================================
#                       STATISTICS CALCULATION
# =============================================================================


def get_class_stats(instances: List[instance_dict]) -> class_stats:
    """Collects statistics for a single class based on its instances."""
    num_instances = 0
    num_signers = 0
    num_variations = 0

    signer_ids = set()
    variation_ids = set()
    for instance in instances:
        num_instances += 1
        signer_ids.add(instance["signer_id"])
        variation_ids.add(instance["variation_id"])

    num_signers = len(signer_ids)
    num_variations = len(variation_ids)
    return {
        "num_instances": num_instances,
        "num_signers": num_signers,
        "num_variations": num_variations,
    }


def get_set(
    instances: List[instance_dict], set_name: AVAIL_SETS
) -> List[instance_dict]:
    """Filters instances to only include those belonging to a specific set (train/val/test)."""
    filtered_instances = []
    for instance in instances:
        if instance["split"] == set_name:
            filtered_instances.append(instance)
    return filtered_instances


def seperate_by_set(glosses: List[gloss_dict]) -> Dict[AVAIL_SETS, List[gloss_dict]]:
    """Separates glosses by their set (train/val/test)."""
    set_names: List[AVAIL_SETS] = ["train", "val", "test"]
    sets: Dict[AVAIL_SETS, List[gloss_dict]] = {name: [] for name in set_names}
    for gloss in glosses:
        instances = gloss["instances"]
        for set_name in sets.keys():
            filtered_instances = get_set(instances, set_name)

            sets[set_name].append(
                {"gloss": gloss["gloss"], "instances": filtered_instances}
            )
    return sets


def get_per_class_stats(glosses: List[gloss_dict]) -> Dict[str, class_stats]:
    """Collects statistics for all classes in a list of gloss_dicts (recommend seperating into test/val/train first)"""
    per_class_stats = {}
    for gloss in glosses:
        class_name = gloss["gloss"]
        instances = gloss["instances"]
        per_class_stats[class_name] = get_class_stats(instances)
    return per_class_stats


def get_unique_signers(dataset: List[gloss_dict]) -> set[int]:
    """Get set of unique sighners in a list of gloss_dicts"""
    signers = set()
    for gloss_d in dataset:
        for instance_dict in gloss_d["instances"]:
            signers.add(instance_dict["signer_id"])
    return signers


def get_num_instances(dataset: List[gloss_dict]) -> int:
    """Get the number of instances in a dataset"""

    num_instances = 0
    for gloss_d in dataset:
        num_instances += len(gloss_d["instances"])
    return num_instances


def get_set_stats(subset: List[gloss_dict]) -> set_stats:
    """Get stats for a particular set (one of test/val.train, seperate first)"""
    return set_stats(
        num_instances=get_num_instances(subset),
        num_signers=len(get_unique_signers(subset)),
        per_class_stats=get_per_class_stats(subset),
    )


def get_per_set_stats(glosses: List[gloss_dict]) -> Dict[AVAIL_SETS, set_stats]:
    """Seperates into sets, then returns stats per set"""
    sets = seperate_by_set(glosses)
    per_set_stats = {}
    for set_name, glosses_subset in sets.items():
        per_set_stats[set_name] = get_set_stats(glosses_subset)
    return per_set_stats


def get_split_stats(split: List[gloss_dict]) -> split_stats:
    return split_stats(
        num_classes=len(split),
        num_instances=get_num_instances(split),
        num_signers=len(get_unique_signers(split)),
        per_set_stats=get_per_set_stats(split),
    )

#TODO: Instances per video id

# Generated by copilot from here:
# =============================================================================
#                       LaTeX TABLE GENERATION
# =============================================================================


def latex_set_summary_table(split_name: AVAIL_SPLITS, stats: split_stats) -> str:
    """
    Generate a LaTeX table summarising statistics for each set (train/val/test)
    for a given split.

    Parameters
    ----------
    split_name : AVAIL_SPLITS
        Name of the dataset split, e.g. "asl100".
    stats : split_stats
        Statistics structure for the split.

    Returns
    -------
    str
        A LaTeX table environment as a string.
    """
    rows = []
    for set_name, s in stats["per_set_stats"].items():
        rows.append(
            f"{set_name} & {s['num_instances']} & {s['num_signers']} & "
            f"{len(s['per_class_stats'])} \\\\"
        )

    table = (
        r"""
        \begin{table}[h]
        \centering
        \begin{tabular}{lccc}
        \hline
        Set & Instances & Signers & Classes \\
        \hline
        """
        + "\n".join(rows)
        + r"""
        \hline
        \end{tabular}
        \caption{Statistics summary for split %s.}
        \end{table}
        """
        % split_name
    )

    return table.strip()


def latex_class_stats_table(
    split_name: AVAIL_SPLITS,
    set_name: AVAIL_SETS,
    set_stats_obj: set_stats,
) -> str:
    """
    Generate a LaTeX table listing per-class statistics for a chosen subset.

    Parameters
    ----------
    split_name : AVAIL_SPLITS
        Name of the dataset split (e.g., "asl100").
    set_name : AVAIL_SETS
        The subset to summarise (train/val/test).
    set_stats_obj : set_stats
        The statistics object for the chosen set.

    Returns
    -------
    str
        A LaTeX table environment as a string.
    """
    rows = []
    for gloss, cstats in set_stats_obj["per_class_stats"].items():
        rows.append(
            f"{gloss} & {cstats['num_instances']} & "
            f"{cstats['num_signers']} & {cstats['num_variations']} \\\\"
        )

    table = (
        r"""
        \begin{table}[h]
        \centering
        \begin{tabular}{lccc}
        \hline
        Gloss & Instances & Signers & Variations \\
        \hline
        """
        + "\n".join(rows)
        + r"""
        \hline
        \end{tabular}
        \caption{Class-level statistics for %s (%s split).}
        \end{table}
        """
        % (set_name, split_name)
    )

    return table.strip()


# =============================================================================
#                       VISUALISATION HELPERS
# =============================================================================


def barplot_metric(
    per_class: Dict[str, class_stats],
    metric: str,
    top_n: Optional[int] = None,
    title: Optional[str] = None,
    figsize: tuple = (12, 6),
) -> None:
    """
    Create a bar plot for a chosen metric across glosses.

    Parameters
    ----------
    per_class : dict
        Mapping gloss → class_stats.
    metric : str
        One of {"num_instances", "num_signers", "num_variations"}.
    top_n : int, optional
        If provided, only plot the top-N glosses for the chosen metric.
    title : str, optional
        Plot title.
    figsize : tuple
        Matplotlib figure size.
    """
    if metric not in {"num_instances", "num_signers", "num_variations"}:
        raise ValueError(f"Invalid metric: {metric}")

    # Extract metric values per gloss
    items = [(g, stats[metric]) for g, stats in per_class.items()]
    items.sort(key=lambda x: x[1], reverse=True)

    if top_n:
        items = items[:top_n]

    glosses, values = zip(*items)

    plt.figure(figsize=figsize)
    plt.bar(glosses, values)
    plt.xticks(rotation=90)
    plt.ylabel(metric.replace("_", " ").title())
    if title:
        plt.title(title)
    plt.tight_layout()
    plt.show()


def histogram_metric(
    per_class: Dict[str, class_stats],
    metric: str,
    bins: int = 20,
    title: Optional[str] = None,
    figsize: tuple = (8, 5),
) -> None:
    """
    Plot a histogram of a chosen metric across glosses.

    Parameters
    ----------
    per_class : dict
        Mapping gloss → class_stats.
    metric : str
        One of {"num_instances", "num_signers", "num_variations"}.
    bins : int
        Number of histogram bins.
    title : str, optional
        Plot title.
    figsize : tuple
        Matplotlib figure size.
    """
    if metric not in {"num_instances", "num_signers", "num_variations"}:
        raise ValueError(f"Invalid metric: {metric}")

    values = [stats[metric] for stats in per_class.values()]

    plt.figure(figsize=figsize)
    plt.hist(values, bins=bins)
    plt.xlabel(metric.replace("_", " ").title())
    plt.ylabel("Frequency")
    if title:
        plt.title(title)
    plt.tight_layout()
    plt.show()


def scatter_instances_vs_signers(
    per_class: Dict[str, class_stats],
    figsize: tuple = (6, 5),
    title: Optional[str] = None,
) -> None:
    """
    Scatter plot of num_instances vs num_signers for each gloss.

    Parameters
    ----------
    per_class : dict
        Mapping gloss → class_stats.
    figsize : tuple
        Figure size.
    title : str, optional
        Plot title.
    """
    x = [c["num_instances"] for c in per_class.values()]
    y = [c["num_signers"] for c in per_class.values()]

    plt.figure(figsize=figsize)
    plt.scatter(x, y, alpha=0.7)
    plt.xlabel("Number of Instances")
    plt.ylabel("Number of Signers")
    if title:
        plt.title(title)
    plt.tight_layout()
    plt.show()
